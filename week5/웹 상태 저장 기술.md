

## 웹 상태 저장 기술

### 1. 쿠키와 세션

#### 쿠키와 세션을 사용하는 이유

- HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다.

- HTTP 프로토콜 환경에서 서버는 클라이언트가 누구인지 확인해야한다. 

- 그 이유는 HTTP 프로토콜이 connectionless, **stateless**한 특성이 있기 때문이다.

- Connectionless

  - 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징
  - HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라이언트에게 요청에 맞는 response를 보내고 접속을 끊는 특성이 있다.
  - 헤더에 keep-alive라는 값을 줘서 커넥션을 재활용하는데 HTTP1.1에서는 default

- Stateless

  - 통신이 끝나면 상태를 유지하지 않는 특징
  - 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성이 있다.

  ![](https://media.vlpt.us/images/gjrjr4545/post/de19f1e2-4f9e-40f8-b867-77de5e04cf1d/image.png)

#### 쿠키와 세션 비교

|          |                     Cookie                      |     Session      |
| :------: | :---------------------------------------------: | :--------------: |
| 저장위치 |                     Client                      |      Server      |
| 저장형식 |                      Text                       |      Object      |
| 만료시점 | 쿠키 저장시 설정 (설정 없으면 브라우저 종료 시) | 정확한 시점 모름 |
|  리소스  |               클라이언트의 리소스               |  서버의 리소스   |
| 용량제한 |        한 도메인 당 20개, 한 쿠키당 4KB         |     제한없음     |

- 저장 위치

  - 쿠키 : 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크
  - 세션 : 서버의 메모리

- 만료 시점

  - 쿠키 : 저장할 때 expires 속성을 정의해 무효화시키면 삭제될 날짜를 정할 수 있음
  - 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화 되기 때문에 정확한 시점 알 수 없음

- 리소스

  - 쿠키 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원 사용하지 않음
  - 세션 : 세션은 서버에 저장되고, 서버 메모리로 로딩 되기 때문에 세션이 생길 때마다 리소스를 차지함

- 용량 제한

  - 쿠키 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 것을 막고자 한 도메인당 20개, 하나의 쿠키 당 4KB로 제한해 둠

  - 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한 없음

- 라이프사이클
  - 쿠키 : 클라이언트에 파일로 저장되어 브라우저가 종료되어도 정보가 남아있음. 만료시간을 지정할 수 있어 쿠키 삭제하기 전까지 유지할수 있다.
  - 세션 : 만료시간을 정할 수 있지만, 브라우저 종료시에 삭제된다.

#### 쿠키의 특징

- **클라이언트(브라우저) 로컬에 저장**되는 **키와 값**이 들어있는 작은 데이터 파일.
- **사용자 인증이 유효한 시간을 명시**할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있음.
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조한다.
- 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장한다.
- **Response Header에 Set-Cookie** 속성을 사용하면 클라이언트에 쿠키를 만들 수 있다.
- 쿠키는 사용자가 따로 요청하지 않아도 클라이언트(브라우저)가 **Request시에 Request Header를 넣어서 자동으로 서버에 전송**한다.

#### 쿠키의 구성 요소

- 이름 : 각각의 쿠키를 구별하는데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

#### 쿠키의 동작 방식

<img src="https://cinabrosite.files.wordpress.com/2017/01/session-53a21.png" style="zoom:80%;" />

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함 시켜 응답 (Set-Cookie: < cookie-name > = < cookie-value >)
4. 브라우저가 종료되어도 쿠키 만료 시간이 있다면 클라이언트에서 보관하고 있음
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

#### 세션의 특징

- 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 **세션은 서버 측에서 관리**한다.
- **서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여**하며 **웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지**한다.
- **접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정**이 가능하다.
- 사용자에 대한 정보를 서버에 두기 때문에 **쿠키보다 보안에 좋지만**, **사용자가 많아질수록 서버 메모리를 많이 차지**하게 된다. (성능 저하의 요인)
- 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데 이것이 세션ID다.

#### 세션의 동작 방식

<img src="https://cinabrosite.files.wordpress.com/2017/01/session-71f08.png" style="zoom:80%;" />

1. 클라이언트가 서버에 접속 시 세션 ID를 발급받음
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음.
3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용.
4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져옴.
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답.



### 2. JWT(Json Web Token)

- 인증에 필요한 정보들을 암호화시킨 토큰

- 세션 방식처럼 토큰 자체를 쿠키에 담아서 보내줄 수도 있고 HTTP 헤더에 담아서 보내줄 수도 있다.

- 웹표준 (RFC 7519)을 따른다.

- 장점

  - 수많은 프로그래밍 언어에서 지원
    - JWT 는 C, Java, Python, C++, R, C#, PHP, JavaScript, Ruby, Go, Swift 등 대부분의 주류 프로그래밍 언어에서 지원된다.

  - 자가 수용적 (self-contained) 입니다
    - JWT 는 필요한 모든 정보를 자체적으로 지니고 있다.
    - JWT 시스템에서 발급된 토큰은, 토큰에 대한 기본정보, 전달 할 정보 (로그인시스템에서는 유저 정보를 나타내겠죠?) 그리고 토큰이 검증됐다는것을 증명해주는 signature 를 포함하고 있다.

  - 쉽게 전달 될 수 있습니다
    - JWT 는 자가수용적이므로, 두 개체 사이에서 손쉽게 전달 될 수 있다.
    - 웹서버의 경우 HTTP의 헤더에 넣어서 전달 할 수도 있고, URL 의 파라미터로 전달 할 수도 있다.

#### 토큰의 구성 요소

<img src="https://hudi.kr/wp-content/uploads/2015/10/1.jpeg" style="zoom:100%;" />

- Header: 3가지 요소를 암호화할 알고리즘 등과 같은 옵션이 들어간다.

- Payload: 유저의 고유 ID 등 인증에 필요한 정보가 들어간다.

- Verify Signature: Header, Payload와 Secret Key가 더해져 암호화된다.

- Header.PayLoad.VerifySignature로 만들어진다.

  - Header와 Payload는 누구나 디코딩하여 내용을 확인할 수 있기때문에 유저의 비밀번호 같은 정보는 넣지 않도록 한다.

  - 하지만 Secret Key를 알지 못하면 VerifySignature는 복호화할 수 없다.

    

### 3. 웹 캐시

#### 캐싱 기본 개념

- 캐싱(Caching)은 애플리케이션의 처리 속도를 높여준다. 
- 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있다. 
- 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.

#### 웹 캐시

- 사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있다.

#### 웹 캐시의 종류

- Browser Caches

  - 브라우저 또는 HTTP요청을 하는 Client Application에 의해 내부 디스크에 캐쉬

  - Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache

  -  브라우저의 Back버튼 또는 이미 방문한 페이지를 재 방문하는 경우 극대화
  - 정적인 자산(이미지, HTML, CSS, Javascript)을 캐시한다.

- Proxy Caches
  - Browser Cache와 동일한 원리로 동작하며 Client나 Server가아닌 네트워크 상에서 동작.
  - 큰회사나 IPS의 방화벽에 설치 되며 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록등 수행
  - 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐쉬

- Gateway Caches (REVERSE OR SURROGATE PROXY)
  - 서버 앞 단에 설치되어 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
  - Encryption / SSL acceleration, Load balancing, Serve/cache static content, Compression등을 수행
  -  무한대의 클라이언트들에게 한정된 수(또는 하나)의 웹서버 컨텐츠를 제공



